# はじめての Deno

## はじめに

本章ではプログラミングが初めての人向けに Deno の基本的な使い方を説明していきます.

### Deno ってなに?

Deno は JavaScript の実行エンジンです. Deno では JavaScript 言語と Deno 独自の命令を組み合わせて様々なプログラムを書くことが出来ます. Deno は 2010年代にアメリカのソフトウェアエンジニアによって開発が始められました. Deno という名前は, Deno が参考にしている JavaScript エンジンである "Node" のアナグラム (アルファベットの順番並び替え) として名付けられました. Deno は英語の Dino (Dinosaur = 恐竜) と発音が似ているため, Deno のマスコットキャラクターは恐竜になっています.

### Deno で出来ること

Deno は汎用の JavaScript のエンジンのため, コンピュータ上のあらゆる処理をプログラミングすることが出来ます. 例えばファイルを操作したり, インターネットからデータをダウンロードして収集したりするタスクは Deno は得意です. また, Deno はサーバーを立ち上げることも得意です. 標準ライブラリに含まれる http モジュールや, ws (WebSocket) モジュールを使えば, Web サービスのバックエンドになるサーバーを少ないコーディング量で作成することが出来ます.

### Deno の特徴

JavaScript で簡単に書けるシンプルなプログラミング環境というのが Deno の特徴ですが, それ以外にもいくつか特徴的な点があります.

#### TypeScript も使える

Deno は JavaScript だけでなく TypeScript も実行することが出来ます. TypeScript は基本的な文法構造は JavaScript とほぼ同じ言語ですが, 更に変数の型情報を追加して記述することができます. 型情報を書くことで, プログラムの部品である変数や関数がどのようなデータ型を持っているかが明確化され, コンパイラによって自動的にチェックされるようになるため, プログラムのバグを減らす事が出来ます.

通常は TypeScript を利用する場合は, Node.js 環境に, TypeScript コンパイラや, ts-node などのランナーをインストールして使うことになります. また, コンパイラに指示を出すための tsconfig.json という設定ファイルが必要になるなど, 各種の準備が必要になります. Deno はそれらの設定を全て内部に含んでいるため, 準備の必要なく, いきなり TypeScript のソースコードを実行することが出来ます.

#### 独自のセキュリティ機構がある

Deno は特殊なセキュリティのコントロールの仕組みを持っています. Deno は実行時にコマンドラインオプションで, プログラムが何をして良い, 何はしてはいけないということをあらかじめ決めてから実行します. 例えば, リンターのようなファイルの読み込みしか必要としないはずのプログラムはファイルの読み込み権限だけを与えて実行するのが適切です. リンターがネットワークアクセスを使用していたら何かがおかしい疑いがあります. Deno ではこのようなケースで

```
deno --allow-read linter.js
```

のようにプログラムを実行することで, 実際にファイル読み込みしか許可しない状態でプログラムを実行できます. また, 例えばネットワークアクセスだけを許可する場合は次のようになります.

```
deno --allow-net network.js
```

更に Deno はホワイトリストの仕組みを持っています. 上のセキュリティコントロールを, ホワイトリストに対してより細やかに行うことが可能です.

```
deno --allow-net=https://example.com network.js
```

上の例では `network.js` というプログラムを `https://example.com` というドメインへのネットワークリクエストのみを許可した状態で行わせることが出来ます.

このように, Deno では, そのプログラムが本来使用するべきコンピュータの機能に絞って権限を渡す仕組みがあります. これは意図しない第3者の攻撃コードがソースコードに混入してしまった場合に, 被害を防げるという利点があります.

近年 Node では, パッケージレジストリの npm に攻撃コードの混入が見つかるケースが増えています. その多くのケースで, 攻撃者は攻撃コードを使ってそのコンピュータの機密情報を, 自分が用意したサーバーに送信して盗もうとします. Deno のセキュリティの仕組みを使えばこの送信時のネットワークアクセスを防ぐことが出来るため, このようなタイプの攻撃が成り立たなくなります.

## Deno の開発環境を構築しよう

それでは実際に Deno を動かすための環境を構築していきましょう.

### Windows で Deno をインストールする

この節では Windows に Deno をインストールする方法を説明します.

{SS: デスクトップ:左下検索に矢印}

左下の検索ボックスに `powershell` (TODO: チェック) と入力してパワーシェルを開きます.

{SS: パワーシェル}

パワーシェルが開いたら, 次のように入力して Deno をダウンロードしましょう.
TODO: チェック
```
iwr deno.land/x/install/install.ps1 -useb | iex
```

以下のように表示されればダウンロード成功です.

{SS: DL 完了の図}

ダウンロードが成功したら, 環境変数の設定をしていきましょう.

左下の検索ボックスに, コントロールパネルと入力して, コントロールパネルを開きます.

{SS: デスクトップ:左下検索にコントロールパネル}

コントロールパネルからシステムと環境設定を右クリックします.

{SS: コントロールパネル内システムと環境設定右クリックした図}

環境変数の設定を選択します.

{SS: コントロールパネル内システムと環境設定}

`Path` 環境変数を選びます.

{SS: 環境変数設定画面}

`c:\.../deno` を入力して, 保存を押します. (TODO: インストールパスチェック)

パワーシェルに戻って, `deno -v` と入力します.

{SS: deno -v in psh}

上のように Deno のバージョン情報が表示されればインストール完了です.

---

コラム: scoop を利用する

scoop がインストールされている場合は, 次のコマンドで deno をインストールすることが出来ます.

```
scoop install deno
```

この場合は環境変数の設定は不要です.

---

### Mac で Deno をインストールする

{図: マック, デスクトップ}

画面右上の🔍をクリックしてスポットライトを開いてください.

スポットライトの検索ボックスに「ターミナル」と入力して, ターミナルアプリを選択してください.

{図: ターミナル}

上のようなターミナル画面が開いたはずです.

ターミナル上で, 下のコマンドを入力して Deno をダウンロードしましょう.

```
curl -L deno.land/x/install/install.sh | sh
```

ダウンロード完了したら, 以下の行を `~/.bash_profile` に追加して `deno` コマンドにパスを通します.

```
export PATH=$HOME/.deno/bin:$PATH
```

以上を `~/.bash_profile` に追加したら, 下のコマンドを打って, `~/.bash_profile` を再ロードします.

```
. ~/.bash_profile
```

ここまでで Deno のインストールは完了です. インストールできたことを確認するために, 下のコマンドを打ってみてください:

```
deno -v
```

インストールが成功していたら, 以下のように `deno` バージョン情報が表示されるはずです.

```
$ deno -v
deno: 0.13.0
v8: 7.7.200
typescript: 3.5.1
```

上のメッセージが確認できたら, インストールは完了です.

---

コラム: Homebrew をインストールしている場合は brew コマンドでもインストールできます.

ターミナルから以下のコマンドを叩いてみてください.

```
brew install deno
```

こちらのコマンドでインストールする場合は `~/.bash_profile` の編集は不要です

---

### Deno プログラムを実行するには

Deno のプログラムの実行の仕方は大きく分けて2種類あります.

1つはインタラクティブシェル(対話型入力欄)からプログラムを直接入力するやり方です. もう1つはファイルに保存した Deno プログラムを `deno` コマンドに読み込ませて実行するやり方です.

#### インタラクティブシェルから Deno プログラムを実行する

先ずはインタラクティブシェルから Deno プログラムを実行する方法を説明します. インタラクティブシェルというのは Deno の対話型の実行環境のことです. この環境に入ると, 入力した Deno プログラムを即座に Deno が実行し, 結果を返してくれます. このような環境のことは REPL (リプル, Read-Eval-Print Loop) とも呼ばれます.

インストールの節で説明した方法で, 先ずはターミナル(パワーシェル)を起動してください.

ターミナルで, 次のように `deno` と入力して [Enter] キーを入力してください.

```
deno
```

すると次のように `>` の記号が表示されるはずです.

```
deno⏎
>
```

このような表示にならなかった場合は, インストールがうまくできていません. 前の節に戻って, インストールの手順をもう一度確認してみましょう.

`>` の記号が表示されたら, この状態がインタラクティブシェル環境です. ここに Deno プログラムを入力することが出来ます.

まずは以下のように入力してみましょう.

```
> console.log("hello world")
```

(console.log は表示をするための命令です)

最後まで入力したら [Enter] キーを押します.

すると次のように 1行下に `hello world` の文字が出力されるはずです.

```
> console.log("hello world")⏎
hello world
```

上の出力が確認できれば, インタラクティブシェルからの Deno プログラムの実行が成功したことになります.

#### Deno プログラムを書いたファイルを実行する

次にファイルから Deno プログラムを実行してみましょう.

上で入力したのと同じ内容の文字列を, ファイルに書いて保存しましょう.

```
console.log("hello world")
```

保存したら, 再度ターミナルを開き `deno` と入力し, 更にスペースを1つ入力し, その状態で保存したファイルをターミナルにドラッグ・アンド・ドロップしてください.

すると, ターミナルにファイルのパスが表示されます.

```
deno /Users/kt3k/Desktop/hello.js
```

この状態でエンターキーを押してファイルを実行します.

```
deno /Users/kt3k/Desktop/hello.js⏎
hello world
```

上記のように `hello world` と表示されれば成功です.

## Deno プログラミングをはじめよう

ここまでで Deno でプログラムを動かすことが出来るようになりました. この節からは, Deno を使って基礎的なプログラミングを学んでいきましょう.

### プログラミングとは

そもそもプログラミングとはなんでしょうか? 私たちは普段人にものをお願いするときは, 日本語でしてほしい事をお願いします.

一方, コンピュータに何かをしてほしい時に, 日本語で頼んでもコンピュータには理解できません. コンピュータに理解できる言語を使う必要があります. そのようなコンピュータに理解できる言語が「プログラミング言語」と呼ばれるものです.

ここで人が話す言語とプログラミング言語の関係を表にすると以下のような対応関係になります.

|対 人間   |対 コンピュータ   |
|----------|------------------|
|言語      |プログラミング言語|
|文書を書く|プログラミング    |
|文章      |プログラム        |

人が話す言語には日本語, 英語, 中国語など様々な種類があるように, プログラミング言語にも JavaScript, Python, Go のように様々な種類があります.

### Deno で計算してみよう

それではターミナルを開いて `deno` [Enter] キーと入力してインタラクティブシェル環境を開いてください. ( やり方を忘れてしまった人は → 1.2.3 節を参照してください. )

```
deno⏎
>
```

上のような記号 > が表示されたはずです. この状態は Deno のインタラクティブシェルというものでした.

#### 足し算, 引き算

足し算は `+`, 引き算は `-` で計算することが出来ます.

ではまず 1+1 を Deno で計算してみましょう. 1+1 と入力してから [Enter] キーを押してみましょう.

```
> 1+1⏎
2
```

では, 他の計算もしてみましょう.

```
> 3+5
8
> 12+56
68
> 5-2
3
> 56-30
26
> 1729-3000
-1271
```

#### 掛け算, 割り算

掛け算は `*`, 割り算は `/` を使います.

```
> 34 * 12
408
> 100 * 1.08
108
> 56 / 7
8
> 56 / 9
6.222222222222222
```

#### 演算子の優先順位

足し算, 引き算, 掛け算, 割り算の使い方がわかりました. これら4つの演算をまとめて4則演算と呼びます.

次に, これらの4則演算を混ぜて計算してみましょう.

```
> 10 + 20 * 3 - 40
30
> (10 + 20) * 3 - 40
50
```

このように, 足し算と掛け算が混ざっている式の場合は, 掛け算が優先して計算されていることがわかります. このルールは数学の四則演算の優先順位のルールと同じです.

#### 剰余 (割り算のあまり)

4則演算以外にも計算をするための演算子が用意されています. `%` 記号を使うと剰余演算(割り算の余りを求める計算)を行うことが出来ます.

```
> 4%3
1
```

剰余演算は周期的な処理を行いたい場合に使う演算です. 例えば, 偶数奇数を判定したり, 4回に1回だけ何かをしたい時などに利用します.

#### べき乗

べき乗は1つの数を繰り返し掛け算する演算です. 4の3乗であれば, 4を3回掛け合わせた数, すなわち64 になります. 記号としては `**` を使います.

```
> 4**3
64
> 9**3
729
> 12**3
1728
> 2**16
65536
> 1**100
1
```

#### まとめ

Deno で使う算術演算子は以下のようなものがあります.

|記号|使い方  |意味  |
|----|--------|------|
| +  | 1+1    |足し算|
| -  | 1-1    |引き算|
|`*` | 1`*`1  |掛け算|
| /  | 1/1    |割り算|
| %  | 1%1    |剰余算|
|`**`| 1`**`1 |べき乗|

### データを便利に扱う - 変数

ここでは変数について説明していきます. 変数とは一定期間のあいだ, 数字や文字などを保存しておける機能です. 例えていうなら, 携帯電話のアドレス帳のようなイメージのものです.

私たちは普段知り合いの電話番号を全ては暗記していませんよね. 相手の名前と電話番号をアドレス帳に登録して, 必要な時に名前で探して, 出てきた電話番号に電話をかけるのが一般的な方法です. これは電話番号という**データ**に, 氏名というラベルを付けて保存していると言い換えることが出来ます.

変数の仕組みは, このアドレス帳の仕組みに似ています. まず, プログラムの中で使いたい数値や, 文字列などのデータをプログラム内で用意したら, それにラベルを付けます. そのラベルを使ってデータを呼び出すことが出来ます. このラベルが変数です.

ここまで, Deno を使って様々な計算をしてきました. ここで新しい機能 変数 を使ったプログラムの書き方を学んでいきます. プログラムでの変数の記述方法は, 次のように変数と値のあいだに = (イコール) を書きます.

```
変数 = 値
```

これを, 変数に値を「セットする」と言います. 先ほどのアドレス帳の例でいうと, 電話番号に, 氏名というラベルを貼る作業に = を使うということです.

算数や数学では = 記号は `2 + 2 = 4` のように, 左辺と右辺が等しいことを表す記号として使っていましたが, Deno では変数に値をセットするための演算子として使います.

実際にインタラクティブシェルを起動して, 変数を使ったプログラムを書いてみましょう.

```
> tax = 0.08
0.08
> price = 120
120
> koike_telephone = '090-0123-4567'
090-0123-4567
```

一行目は tax という変数に 0.1 という数値をセットしました. 2行目は price という変数に 120 という数値をセットしました. 3行目は変数 koike_telephone に '090-0123-4567' という文字列をセットしました.

次にセットできていることを確認していきます. tax と入力し, [Enter] キーを入力してください. price, koike_telephone も同様に, 入力, 確認します.

```
> tax
0.08
> price
120
> koike_telephone
090-0123-4567
```

tax, price, koike_telephone と入力して, [Enter] キーを押すと, 変数に保存した数値や文字列が表示されました. これで, 変数にデータが保存されていることが, 確認できたことになります.

次にこれらの変数を使って, 掛け算をしてみます.

```
> price * tax
9.6
> 120 * 0.08
9.6
```

変数を使って計算をした結果と, 実際に値を掛け合わせた結果が同じになったことがわかります.

#### 変数に使える文字

変数名は自由に名前をつけることが出来ますが, どんな文字でも使えるわけではありません. 変数の名前には次のようなルールがあります.

- 1文字めに数字は使えない
- 予約語は使えない
- _ 以外の記号は使えない

```
> value = 100
100
> value_ = 100
100
> 1value = 200
error: Uncaught SyntaxError: Invalid or unexpected token
► <unknown>:1:1
    at evaluate (js/repl.ts:87:34)
    at replLoop (js/repl.ts:145:13)
```

`value` と `value_` という2つの変数名では, 何も問題が起きませんでした. ところが, 先頭に数字を付けた `1value` を変数名に使うと, `error: Uncaught SyntaxError: Invalid or unexpected token` というエラーが表示されてしまいました. これを日本語に翻訳すると「エラー: 処理されていない構文上のエラー: 不正あるいは予期していないトークン」となります. 構文とは Deno の文法のことです. トークンは文法上の単位で, この場合は `1value` の中の `1` のことを指しています. このことから数字から始まる変数名はつけられないことがわかりました.

次に予約語は使えないというルールについてですが, まず予約語について説明します. 予約語とは Deno の中で使い方あらかじめ決まっている言葉のことです. 予約というとイメージが湧きにくいかもしれませんが, Deno の中で使い方が予約されている言葉というような意味です.

この予約語を変数として使おうとするとどうなるでしょうか? Deno の予約語の try と catch を使って試してみましょう.

```
> try = 1
error: Uncaught SyntaxError: Unexpected token '='
► <unknown>:1:5
    at evaluate (js/repl.ts:87:34)
    at replLoop (js/repl.ts:145:13)
```

```
> catch = 1
error: Uncaught SyntaxError: Unexpected token 'catch'
► <unknown>:1:1
    at evaluate (js/repl.ts:87:34)
    at replLoop (js/repl.ts:145:13)
```

やはり, 構文エラー(SyntaxError)になりました.

なお, Deno には以下のような予約語があります. 正しく変数名をつけたはずなのに, 変数名が構文エラーになってしまった時は, 以下の表を参照してみてください.

- break
- case
- catch
- continue
- debugger
- default
- delete
- do
- else
- finally
- for
- function
- if
- in
- instanceof
- new
- return
- switch
- this
- throw
- try
- typeof
- var
- void
- while
- with

#### まとめ

この節では, 変数について説明しました.

<!--今はまだ単純な計算しか行っていないため, ただ数値を置き換えただけの変数の恩恵はあまり感じられないかもしれませんが, これから新しい機能を覚えて, 徐々に複雑なことに挑戦していくに従って, 変数を使って効率よくプログラミングができることが実感できるはずです.-->

### どちらが大きい? - 比較演算子

この節では Deno の比較演算子を説明していきます. 比較演算子はその名の通り, 比較に使う演算子です. 世の中では, どちらが良いか, どちらが好きか, などの色々な比較がありますが, プログラミングの世界では, どちらの数値が大きいか, などのようにデータの比較を行います.

それでは, 実際にインタラクティブシェルを起動しては確認してみましょう. まずは 35 > 24 と入力して, 実行してください.

```
> 35 > 24
true
```

35 と 24 を > で比較した結果, true という文字が表示されました. これは 35 > 24 が真(true)である(正しい)という意味です. 次に, 不等号の向きを変えて実行してみましょう.

```
> 35 < 24
false
```

今度は false と表示されました. これは 35 < 24 が偽(false)である, つまり誤りであるということを表しています. このようにプログラムでは正しいことを true (真), 誤りであることを false (偽) として扱います. この大なり(>)小なり(<)以外の比較演算子は, 次の表の通りです.

|比較演算子| 例      | 意味                      |
|----------|---------|---------------------------|
| >        | x > y   | x は y より大きい         |
| >=       | x >= y  | x は y より大きいか等しい |
| <        | x < y   | x は y より小さい         |
| <=       | x <= y  | x は y より小さいか等しい |
| ==       | x == y  | x は y と等しい           |
| !=       | x != y  | x は y と等しくない       |
| ===      | x === y | x は y と厳密に等しい     |
| !==      | x !== y | x は y と厳密に等しくない |

ここで注意したいのが, 等しいことを比較するための, == と === です. 1.3.3 で説明した, 変数に値をセットするための = と間違えてしまうことが多いため, 慣れないうちは気をつけてください.

`=` と `===` の2つを続けて実行してみましょう.

```
> apple = 15
15
> apple === 15
true
```

1行めは apple という変数に 15 をセットしました. 2行めは, apple と 15 という数値が等しいという比較を行って, 真(true) という結果が表示されました.

---
コラム: == と === の違い

比較演算子の表で == と === という2つの似た演算子が出てきました. どちらも等しいことを判定するための演算子ですが, この2つは厳密さが違います. == は**厳密ではない**比較をする演算子で, === は**厳密な**比較をする演算子です. では厳密とはどういうことでしょうか? ここでいう厳密というのはデータの種類が等しいことを判断基準に入れるかどうかということです. == では, 厳密ではない比較なので, データの種類が違っても中身が同じであれば等しいと考えます. === では, データの種類と中身の両方が等しい時だけ等しいと考えます.

具体的にインタラクティブシェルを開いて, 数値の 1 と文字列の '1' をそれぞれ比較してみましょう.

```
> 1 == '1'
true
> 1 === '1'
false
```

このように, == で比較した場合は true, === で比較した場合は false になります. これは 1 と '1' は中身は等しいですが, データの種類としては数値と文字列で異なるため, 通常の比較では等しく, 厳密な比較では等しくないと判断されるためです.

---

### 色々なデータの種類

この節では, Deno で扱う色々なデータの種類, データ型について説明します. Deno で扱えるデータ型はたくさんのものがありますが, ここでは代表的な7つのデータ型について解説します.

#### 数値型

数値型は 1, 2, 10 のような数値を表すための型です. 数値型に対しては 3-1 で説明したような様々な演算を行うことが出来ます. プログラムの中でなんらかの量を表したい時は数値型を使います.

```
a = 12
```

変数 a は数値型になります.

#### 文字列型

文字列型は「データを文字の列として扱う」ためのデータ型です. 文字をシングルクオーテーション `'` あるいはダブルクオーテーション `"` で囲むと, 文字列型として扱うようにプログラムに伝えることが出来ます. 例えば変数 message に 'hello' をセットした場合には, 変数 message は文字列型になります.

```
> message = 'hello'
hello
> message
hello
```

##### 文字列の便利な機能

文字列型には様々な便利な機能があります. ここではそのいくつかを紹介します.

toUpperCase() は文字列を全て大文字に変換してくれる機能です.

```
> text = 'hello'
> text.toUpperCase()
HELLO
```

1行目は, 小文字で hello という単語を, 文字列型として text という変数にセットしています. 2行目で変数 text の後ろにドット . をつけて toUpperCase() と書きます. すると変数 text の中身が全て大文字に変換されて3行目に表示されました. 逆に全て小文字に変換する場合は toLowerCase() を使います.

他にも文字列を指定された数だけ繰り返す repeat() という機能があります.  早速プログラムを書いてみましょう

```
> text = 'hello'
> text.repeat(5)
hellohellohellohellohello
```

1行目は text という変数に hello という文字列をセットしました. そして, 2行目で, 変数 text に続けて .repeat(5) と入力しました. () の中に 5 と入力したため 5回繰り返すという処理になっています. ここでは hello という文字列を 5回繰り返した結果, 3行目のような内容が表示されました.

これらデータ型が持つ機能をメソッドと言います.

メソッドは一般的に以下のような書式で実行できる機能のことです.

```
変数.メソッド名()
変数.メソッド名(パラメータ1)
変数.メソッド名(パラメータ1, パラメータ2)
変数.メソッド名(パラメータ1, パラメータ2, ...)
...
```

パラメータが幾つ必要になるかはメソッドの種類によって決まります. toUpperCase() はパラメータがないメソッド, repeat() はパラメータが1個のメソッドの例です.

#### 真偽値型

真偽値型は, 真偽値を表すための型です. 数値型や文字列型と違って, 真偽値型には true と false の2つの値しかありません. 前節でも簡単に説明しましたが, 真偽値とはある式が Deno の中で正しいか誤りであるかを表現するための型です.

```
> 1 < 2
true
> 1 > 2
false
```

#### null と undefined

null は「値がない」ことを表すためのデータ型です. なんらかの計算をした結果, 値がないという場合に, null を使ってそのことを表現する場合があります. null 型になるデータは null 値だけです.

```
> a = null
null
> a
null
```

undefined は「定義がされていない」ことを表すためのデータ型です. null と似ていますが, 値がないのではなくそもそも定義されていないことの表現として使われるデータ型です. undefined 型になるデータも null と同様に undefined 値だけです.

```
> a = undefined
undefined
> a
undefined
```

#### 配列 (Array)

配列 (Array) 型は今までのものとは少し違ったデータ型です. 配列型を使うと, 複数のデータをひとまとまりにする事が出来ます. 実際に自分でプログラムを書くようになると, たくさんのデータを扱うこともあり, データをまとめられる便利さを実感できるでしょう. 配列型を使うときは次のような書式を使います. すなわち, まとめたいデータをカンマ `,` で区切り, 全体を `[]` でくくります.

```
[37, 'coffee', 'tea']
```

配列型を使ってひとまとめにした配列は, 他のデータ型と同様に, 変数に入れて扱う事ができます.

```
groupA = ['kazu', 'goro']
groupB = ['haru', 'syun']
```

#### オブジェクト

オブジェクト型は, リスト型と同様にデータをひとまとめにして扱うためのデータ型です. リスト型はまとめたいデータを, 前から順番に並べたデータ型だったのに対して, オブジェクト型ではデータに順番はありません. その代わりデータにラベルをつけて, ラベルによってデータを管理するデータ型がオブジェクト型です. オブジェクト型のデータを作るにはラベルと値をコロン `:` で区切ったペアを複数並べて, カンマで区切ったものの全体を `{}` でくくる事で作る事ができます.

```
{ "name": "John", "age": 10 }
```

ラベルに使われる文字に演算子に使われる記号(+-/%)などが含まれていない場合はダブルクオーテーションを省略して以下のうように書くこともできます.

```
{ name: "John", age: 10 }
```

オブジェクトの個々のラベルとその値の組の事を **プロパティ** と呼びます. ラベルの事をプロパティ名, 対応する値の事をプロパティの値と呼びます.

次のようにオブジェクトに対して `.` 演算子を使う事でオブジェクトのプロパティを取得する事が出来ます.

```
オブジェクト.プロパティ名
```

実際に, 上のオブジェクトを変数に入れて試してみましょう.

```
person = { name: "John", age: 10 }
```

上の書き方で変数 person に, オブジェクト `{ name: 'John', age: 10 }` をセットしました. セット出来ているか確認してみましょう.

```
> person
{ name: "John", age: 10 }
```

変数 person に上のオブジェクトが保存されている事がわかりましたね. 次に, person オブジェクトのプロパティを取り出してみましょう. プロパティを取り出すために, ドット `.` とプロパティ名をオブジェクトの入った変数の後ろにつけてみます.

```
> person.name
John
```

person オブジェクトの name プロパティは John である事がわかりました. 同様に age プロパティも調べてみましょう.

```
> person.age
10
```

10 と表示されました. このように, オブジェクトの個別のプロパティを確認する事が出来ました.

次にオブジェクトのプロパティの値を変更してみましょう. オブジェクトのプロパティ値を変更するには以下の書式を使います.

```
オブジェクト.プロパティ名 = 値
```

試しに person オブジェクトの age を 11 に変更してみましょう.

```
> person.age = 11
11
```

この状態で person 全体がどうなっているかみてみると,

```
> person
{ name: "John", age: 11 }
```

age が 11 に変更されている事が確認できました. このようにオブジェクトはプロパティ1つづを変更する事ができます.

#### まとめ

ここまでで学んだ様々なデータ型について, それぞれの定義方法をまとめます.

##### 数値型

```
data = 1
data = 1.5
```

数字だけを書くと, 数値型になります. 小数点も使えます.

##### 文字列型

```
data_string = 'str'
data_string = "str"
```

シングルクオーテーションかダブルクオーテーションで囲んだ文字は文字列型になります.

##### 真偽値型

```
data = true
data = false
```

true と false の2種類だけです.

##### 配列型

```
data_array = ['a', 'b', 'c']
data_array = [3, 15, 40]
```

[] を使って要素をまとめます.

##### オブジェクト型

```
data_object = { name: 'John', age: 30 }
data_object = { type: 'animal', kind: 'cat' }
```

`:` でペアを作り, `{}` で全体をまとめます.

## プログラミングの基本編

### こういうとき, どうする? 条件分岐

条件分岐というと難しく聞こえますが, この条件分岐を言い換えると, 「プログラムに, 状況に応じて異なる別々の処理をしてもらう機能」です.

Deno で「もし〇〇だったら, 〇〇する」を表現するには, if というキーワードを使って, 以下のように表現します.


```
if (条件式) {
  プログラム
}
```

条件式の部分には, 3-4 節で学んだ比較演算子などを使った真偽値型のデータが入るようにします. `プログラム` の部分には, 条件式が true になった時にだけ実行したいプログラムを入力します.

{なんらかの例と演習問題}

### 装置を作る - 関数

プログラミングには関数と呼ばれる機能があります. 関数は, いくつかの処理を1つにまとめて, 後から呼び出せるようにする機能です.

関数は function というキーワードを使って作る事ができます.

```
> function hoge() {}
undefined
> hoge
[Function: hoge]
```

これは hoge という関数が定義できたことを表しています.

{なんらかの例と演習問題}

### 繰り返し - for, while

プログラミングにおける基本的な考え方の1つである「繰り返し」について学んでいきましょう.

Deno である一定の回数繰り返し処理をしたい場合は for キーワードを使って以下のように表現します.

```
for (const i of Array(繰り返したい数)) {
  // 繰り返したい処理
}
```

特定回数繰り返すのではなく, すでにある配列データに沿って繰り返したい場合は以下のような書式を使うことができます.

```
for (const item of data) {
  // 繰り返したい処理
}
```

ここまでの繰り返しは, あらかじめ何回繰り返されるかが分かっている繰り返しの例でした. しかし, プログラムの中には何回繰り返す必要があるのかあらかじめわからない繰り返し処理をしたい場合があります. そのような場合に使われるのが, 条件式による繰り返しの構文です. ある条件が満たされる間繰り返し処理を行うためには, while キーワードを使って以下の書式で表現することができます.

```
while (条件式) {
  // 繰り返したい処理
}
```

### エラー

ここまで Deno でプログラムを実行してきた中で, うっかりした入力ミスや, 操作ミスによってエラーをみた方もいることと思います. エラーが出るとドキッとしますが, エラー自体は決して悪いことではありません. この節ではエラーの扱い方を説明します.

## 非同期処理

この節では, 非同期処理と呼ばれる処理について説明します.

### 同期処理と非同期処理

Deno には非同期処理と呼ばれる特別な処理があります.

まず同期と非同期の違いについて説明します. 同期というのは1つ1つの処理を順番に行うことを言います. 逆に非同期は1つ1つの処理を順番に行わず, 後回しにすることを言います.

コンビニのレジを思い浮かべてみましょう. レジに行くと店員さんは以下のような作業をして会計処理をしてくれます.

- 商品のバーコードを読み取る
- 商品の合計額を告げる
- 商品を袋詰めする
- 商品を客に渡す

以上のステップを終えると次のお客さんの会計処理が始まります. これは同期処理です. なぜなら1つ1つの処理が全て順番に行われているからです. ここで, 弁当を温める手順が含まれていた場合を考えてみましょう.

- 商品のバーコードを読み取る
- 商品の合計額を告げる
- 弁当以外の商品を袋詰めする
- **弁当を電子レンジに入れてタイマーをセットする**
- 弁当以外の商品を客に渡す

この段階で, 弁当はまだ電子レンジの中で保温中の状態ですが, 店員さんは次のお客さんの会計処理を始めています. そして, 電子レンジの保温が完了したタイミングで

- 弁当をさっきの客に渡す

という手順が差し込まれます. その後, 店員さんはまた次のお客さんの会計処理を続けます.

この話の中の非同期処理はどれでしょうか? 電子レンジでの保温です. 店員さんは保温する間, 電子レンジの前でただ保温が終わるのを待っているのではなく, 他の作業を行います. 電子レンジが終わったサインを出したタイミングで, 作業を中断して, 電子レンジの中身を取り出します. このように, 自分は別な仕事をやるけど, 後ろで何らかの仕事をしておいてもらって, 終わったら呼んでもらうというタイプの手続きがプログラミンの中にも出てきます. そのような処理を非同期処理と言います.

以下では, 基本的な非同期処理をするための関数を紹介します.

#### setTimeout

ここで setTimeout 関数を説明します. この関数は次のような書式で実行します. 処理とミリ秒数を引数にとって, 指定されたミリ秒数後に処理を実行します.

```
setTimeout(後回しにしたい関数, ミリ秒)
```

インタラクティブシェルを使って動きを確認してみましょう.

```
> setTimeout(function () { console.log('hello') }, 1000)
1
> hello
```

上のように表示されたはずです. 表示の際に hello の部分の表示が少し遅かったはずです. 気がつかなかった人はもう一度, 実行してみましょう.

次に, 1000 の部分を 3000 に変更して実行してみましょう.

```
> setTimeout(function () { console.log('hello') }, 3000)
2
> hello
```

hello が表示されるまでがさらに遅くなったはずです. このように setTimeout を使うと, 指定したミリ秒数だけ後で, 指定した処理を実行する事ができます.

次に setTimeout の呼び出しのすぐ後に別の処理を実行してみましょう.

今度はインタラクティブシェルではなくて, エディタでファイルを開いてみてください. そして次のように入力してみてください.

```
setTimeout(function () {
  console.log(2)
}, 1000)

console.log(1)
```

このファイルを test.js として保存して deno で実行してみます.

```
$ deno test.js
1
2
```

1がすぐに表示されて, 2が少し後で表示されたはずです. なぜ2が先に表示されないのでしょうか? これが上で説明した非同期処理の話につながってきます. 上のプログラムでは `function () { console.log(2) }` という処理を1秒後(1000ミリ秒後)に実行してほしいという, 非同期処理の**登録**を行いました. その時点では登録だけが行われ, 処理はそのまま進んで `console.log(1)` が実行され, 1が表示されます. その1秒後に非同期処理として登録された処理が実行され, 2 が表示されたのです.

#### まとめ

Deno の処理には同期処理と非同期処理の違いがあることを説明しました. 通常の処理は同期処理と呼ばれ前から順番に実行されます. 非同期処理として登録された処理は, 現在より後のなんらかのタイミングで実行されます. 非同期処理を登録してもそこで処理は止まらずに, 後ろに同期処理があれば, そちらの同期処理が優先的に実行されます. 非同期処理は適切なタイミングになった時に実行されます.

setTimeout という関数が非同期処理を行うための基本的な関数で, この関数を使うことで一定時間後に, 処理を非同期に実行する事が出来ました.

### プロミス

非同期処理を応用したデータ型でプロミスというものがあります. この節ではプロミスがどういうものかを説明していきます.

プロミスという名前は, 日本語で約束という意味です. なぜそのような名前がついているのでしょうか? プロミスは, 前節で説明した非同期処理を応用して, 未来のある時に何らかのデータが準備できる事を約束します. 約束されたデータが準備できるとプロミスは解決された (fulfilled), と言われデータを取り出す事が出来ます. 逆に約束が破られる事もあって, その場合はプロミスは拒否された (rejected) と言われ, データは取り出せず代わりにエラーが返ってきます.

例えていうと, フードコートなどで商品を購入した時に渡されるブザーに似ています. そのブザーを持ってあなたは自分の席を選んだり, 別な買い物をしたり, 人と喋ったり好きな事が出来ますが, ブザーが鳴ったらその商品を取りにいきます. ブザー自体は商品ではありませんが, ブザーが鳴ることで, それを商品と交換する事ができるようになります.

Deno のプロミスはこのブザーに似ていて, プロミス自体は値を持っていませんが, プロミスが将来のある時に, データの準備が完了した時に, そのプロミスからデータを貰って続きの操作をする事が出来ます.

以下ではプロミスを返す代表的な関数を紹介します.

#### ファイルの読み書き Deno.readFile, Deno.writeFile

Deno.readFile はファイルを読みこむための関数です. この関数をファイル名を引数にして呼ぶと, ファイルの内容を取得する事が出来ます. 次のような内容のファイルを作ってみてください.

```
Deno.readFile('test.js')
```

そして, 上のファイルを test.js というファイル名で保存してください. そして次のように実行します.

```
deno -A test.js
```

すると以下のように表示されたと思います.

```
Promise {}
```

#### fetch

プロミスを返す代表的な関数の fetch を使って具体例を見ていきましょう. fetch は引数に Web ページの URL を受け取って, その web ページの情報を返す関数です. 試しに `https://example.com` という Web ページにリクエストしてみましょう.

```
> fetch('https://example.com')
Promise {}
```

fetch は確かにプロミスを返している事がわかります. このプロミスから値を取り出すためには, プロミスの .then というメソッドに関数を登録します. まずは fetch の結果を変数に入れてみましょう.

```
> res = fetch('https://example.com')
Promise {}
```

これで変数 res に fetch のプロミスがセットされました. ここからプロミスの内容を取り出すには, .then にデータを処理するための関数を登録します.

```
> res.then(console.log)
Promise {}
Response { status, url, statusText, type, bodyUsed, trailer, headers, body, redirected }
```

Promise {} に続いて `Response { status, url, statusText, type, bodyUsed, trailer, headers, body, redirected }` という行が表示されました. これは fetch 関数が返す Response オブジェクトというものになっています. Response オブジェクトが console.log 関数に渡されたため, kのようあ表示になりなりました.

この Response オブジェクトの中に https://example.com に関するいろいろな情報が入っています. Response オブジェクトの中のいくつかのプロパティを表示して調べてみましょう

```
> res.then(r => { console.log(r.status) })
Promise {}
200
```

`r.status` は Response のステータスというもので, ネットワークリクエストが成功したかどうかを表す数値が入っています. 上の例ではリクエストが成功したため, 成功を表すステータスコードの 200 が表示されています.

```
> res.then(r => { console.log(r.statusText) })
Promise {}
OK
```

`r.statusText` は, Resnponse のステータスのテキストとしての表現です. 成功の場合は OK というステータス表現になります.

```
> res.then(r => { console.log(r.headers) })
Promise {}
Headers {}
```

`r.headers` は Headers オブジェクトというものになっています. ネットワークリクエスト (正確には HTTP リクエスト) には様々なメタ情報がヘッダーとして送受信されていて, Headers オブジェクトにはそのようなメタ情報が入っています. ここでは, Response のデータの種類を表すヘッダーである Content-Type の値を見てみましょう.

```
> res.then(r => { console.log(r.headers.get('Content-Type')) })
Promise {}
text/html; charset=UTF-8
```

このように, このレスポンスは Content-Type ヘッダーが `text/html; charset=UTF-8` という値を持っている事がわかりました. これはすなわちこのレスポンスのデータの内容が html 形式で書かれている事と, その文字コードが UTF-8 である事を表しています.

Response オブジェクトの text() メソッドはさらにプロミスを返す関数になっていて, このプロミスのデータが Web サイトの内容(HTMLソースコード)になります. 実際に取り出してみましょう.

```
> res.then(r => r.text().then(console.log))
Promise {}
> <!doctype html>
<html>
<head>
    <title>Example Domain</title>
    ...(以下略)
```

画面を埋め尽くすぐらい多くの html が表示されたと思います. この表示内容が, https://example.com の表示に利用されている html のソースコードです.

#### まとめ

この説ではプロミスをの使い方を学びました. Deno.readFile や fetch などがプロミスを返す関数である事を学びました.

### async / await 構文

async await 構文はプロミスをより便利に使うための構文です. async await 構文の基本的な使い方は以下のようになります.

```
async function () {
  // ここに await を使った好きな式が書ける
}
```

await 単体の使い方は以下のようになります

```
await プロミス
```

このように書くと `await プロミス` の部分はプロミスが解決するまで処理がそこで止まるようになります. そしてプロミスが解決したタイミングで処理が継続され, プロミスが解決したデータは `await プロミス` という式全体の値として取得する事が出来ます.

前節の Deno.readFile の例を async await 構文で書き換えてみると以下のようになります.

```
async function readFile() {
  const res = await Deno.readFile('test.js')
  console.log(new TextDecoder().decode(res))
}
```

また fetch の例を async await 構文で書き換えてみると以下のようになります.

```
async function getSite() {
  const res = await fetch('https://example.com')
  const text = await res.text()
  console.log(text)
}
```

fetch() が返すプロミスと res.text() が返すプロミスで 2個のプロミスが出てくるため, それぞれに対応して await の個数も2個になっています.

このように await を使うと, プロミスの then() にコールバックを登録する事を省略して, await という演算子を使って中身の値を取り出す事が出来るようになります.

## モジュールを作ってみよう, 使ってみよう

### モジュールとは

モジュールというのはプログラムにとっての道具箱のようなものです. 道具箱には色々な道具が入っていて, 用途に応じて使い分けて, 何かを作ったり, 修理したりします.

Deno にとってのモジュールも似たようなものです. 自分のやりたい作業に対して, 都合の良いモジュールを選ぶ事で, より少ない手間でプログラムを書く事が出来ます.

- color

### モジュールを作ってみる

モジュールの使い方をいくつかみてみましたが, この節ではモジュールを作る方法を説明していきます.

モジュールを作るのは簡単です. 実はモジュールの実体は単なるプログラムが書かれたファイルなのです. 通常のプログラムの関数や変数に export キーワードを使ってモジュールの外部から使用可能な機能を指定すれば, それでモジュールの完成です.

export キーワードは以下の書式で利用します.

```
export const 変数名 = 値
export let 変数名 = 値
```

関数の場合は以下の書式になります.

```
export function 関数名() {
}

export async function 関数名() {
}
```

上の記法を使うことで, export が指定された変数や関数がモジュールの外部から import することができるようになります.

試しに簡単なモジュールを作ってみましょう. 次のようなファイルを作成し, hello.js というファイル名で保存してください.

```
export function hello() {
  console.log('hello')
}
```

hello という関数が定義されていますね. hello は関数として呼ばれると `hello` と出力する関数です. `function` キーワードの前に `export` キーワードが付いているので, この hello 関数はモジュールの外部から import して利用することが可能です.

次のような, ファイルを作成して, main.js というファイル名で保存してください. (hello.js と同じフォルダ内に作成してください.

```
import { hello } from './hello.js'
hello()
```

それでは, この main.js を実行してみましょう.

```
deno main.js
```

`hello` と表示されましたね. うまくいかない場合は, ファイルを保存する場所がおかしく無いか, ファイル名があっているかなどを確認してみてください.

これで, hello 関数を export する hello.js というモジュールを作ったことになります.

### 標準モジュールを使ってサーバを作ってみる

最後に標準モジュールの機能を使って Deno で HTTP サーバを作ってみましょう. その前にサーバとは何かを簡単に説明します.

#### サーバとは

サーバの元々の意味はサービスを提供する人/もの/仕組みのことを言います. コンピュータの世界では, 別のコンピュータからの要求を受け取って, それに応答するプログラムのことをサーバと言います.

#### HTTP サーバ (Web サーバ) とは

サーバは要求に対して応答するプログラムですが, 要求と応答の間には一定のルール(文法のようなもの)があります. そのようなルールはプロトコルと呼ばれます.

プロトコルのうちでインターネットの Web ページを要求/応答するためのルール(プロトコル)は HTTP (ハイパーテキストトランスファープロトコル) と言われます.

HTTP プロトコルの要求に対して応答するプログラムが HTTP サーバです. HTTP サーバは Web ページを表示するためのサーバなので Web サーバとも呼ばれます.

(なお HTTP プロトコル自体の詳細については, denobook 01 第3章「Deno de HTTP Server」や, 「とほほのHTTP入門 ( http://www.tohoho-web.com/ex/http.htm )」などを参照してください.

この節では Deno の標準モジュールを使って HTTP サーバを作る方法を紹介します.

HTTP サーバのための基本機能は標準モジュールの `http/server.ts` にまとめられています. 次のように入力して, `server.js` というファイル名で保存してください.

```
import { serve } from "https://deno.land/std/http/server.ts";

window.onload = async () => {
  const body = new TextEncoder().encode("Hello World\n")
  console.log('Server started!')
  for await (const req of serve(':8000')) {
    req.respond({ body })
  }
}
```

このファイルを以下のように実行しましょう.

```
deno -A server.js
```

標準モジュールのダウンロードが自動的に始まり, 少し待つと `Server started!` と表示されるはずです. 表示がされたら, ブラウザに `localhost:8000` と入力してみましょう. すると以下のように表示されるはずです.

{SS:localhost:8000 のスクショ}

これで HTTP の要求に対して `Hello World` と応答する HTTP サーバーができました.

## まとめ

本章では Deno の基本的な使い方から, 基本構文, モジュールを使った少し高度な使い方までを説明しました.

#### 参考文献
- 考える力が身につく Python 「超」入門 鎌田正浩
- JavaScript Primer @azu
